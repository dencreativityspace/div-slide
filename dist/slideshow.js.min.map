{"version":3,"sources":["div-slide/src/slideshow.js"],"names":["Slideshow","_ref","_this","this","_ref$container","container","_ref$slideshowSelecto","slideshowSelector","_ref$slideSelector","slideSelector","_ref$currentSelector","currentSelector","_ref$duration","duration","_ref$cycle","cycle","_ref$swipe","swipe","_ref$throwsOpenIndexE","throwsOpenIndexError","throwsSlideIndexError","document","querySelector","HTMLElement","Error","that","slideshowClass","substr","currentClass","classList","contains","add","slides","querySelectorAll","current","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","slide","value","err","return","swipeHandler","SwipeEvent","element","itemSelector","activeSelector","Interval","navigateSlide","dir","arguments","length","cycleState","setCurrentSlide","keepInBound","getSlideIndex","index","Array","prototype","indexOf","call","remove","prev","oldCurrent","prevEvent","window","CustomEvent","createEvent","initCustomEvent","active","getCurrentSlide","detail","dispatchEvent","nextEvent","set","Math","abs","concat","settedEvent","old","updateSlides","getContainer","getSwipeHandler"],"mappings":"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","file":"slideshow.js","sourcesContent":["\"use strict\";\n\nfunction Slideshow(_ref) {\n  var _this = this;\n\n  var _ref$container = _ref.container,\n      container = _ref$container === void 0 ? '#slideshow' : _ref$container,\n      _ref$slideshowSelecto = _ref.slideshowSelector,\n      slideshowSelector = _ref$slideshowSelecto === void 0 ? '.slideshow' : _ref$slideshowSelecto,\n      _ref$slideSelector = _ref.slideSelector,\n      slideSelector = _ref$slideSelector === void 0 ? '.slide' : _ref$slideSelector,\n      _ref$currentSelector = _ref.currentSelector,\n      currentSelector = _ref$currentSelector === void 0 ? '.current' : _ref$currentSelector,\n      _ref$duration = _ref.duration,\n      duration = _ref$duration === void 0 ? 0 : _ref$duration,\n      _ref$cycle = _ref.cycle,\n      cycle = _ref$cycle === void 0 ? true : _ref$cycle,\n      _ref$swipe = _ref.swipe,\n      swipe = _ref$swipe === void 0 ? false : _ref$swipe,\n      _ref$throwsOpenIndexE = _ref.throwsOpenIndexError,\n      throwsSlideIndexError = _ref$throwsOpenIndexE === void 0 ? false : _ref$throwsOpenIndexE;\n\n  // Type-checks\n  if (typeof container === 'string') {\n    container = document.querySelector(container);\n  }\n\n  if (!(container instanceof HTMLElement)) {\n    throw new Error('The slideshow container must be a valid DOM element.');\n  } // Shorthand to easily reach `this`.\n\n\n  var that = this; // Class mapping:\n\n  /**\r\n   * CSS class of the slideshow. Applies to container.\r\n   *\r\n   * @constant\r\n   * @type {string}\r\n   *\r\n   * @private\r\n   */\n\n  var slideshowClass = slideshowSelector.substr(1);\n  /**\r\n   * CSS class of the slide. Applies to container.\r\n   *\r\n   * @constant\r\n   * @type {string}\r\n   *\r\n   * @private\r\n   */\n\n  var slideClass = slideSelector.substr(1);\n  /**\r\n   * CSS class for the current slide. Applies to the original selected <div>\r\n   * and the chosen one. Can be applied only to one element at the time.\r\n   *\r\n   * @constant\r\n   * @type {string}\r\n   *\r\n   * @private\r\n   */\n\n  var currentClass = currentSelector.substr(1); // Sets the slideshow class.\n\n  if (!container.classList.contains(slideshowClass)) {\n    container.classList.add(slideshowClass);\n  }\n  /**\r\n   * Gets all the slides.\r\n   *\r\n   * @type {NodeList}\r\n   *\r\n   * @private\r\n   */\n\n\n  var slides = container.querySelectorAll(slideSelector);\n  /**\r\n   * Represents the current element in container.\r\n   *\r\n   * @type {HTMLElement}\r\n   *\r\n   * @private\r\n   */\n\n  var current = function () {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = slides[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var slide = _step.value;\n\n        if (slide.classList.contains(currentClass)) {\n          return slide;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return slides[0] || null;\n  }();\n  /**\r\n   * Contains the swipe handler if SwipeEvent is present.\r\n   *\r\n   * @type {SwipeEvent|null}\r\n   *\r\n   * @private\r\n   *\r\n   * @see {@link https://github.com/dencreativityspace/swipe-event|swipe-event}\r\n   */\n\n\n  var swipeHandler = function () {\n    if (swipe && typeof SwipeEvent === 'function') {\n      return new SwipeEvent({\n        element: container,\n        itemSelector: slideSelector,\n        activeSelector: currentSelector\n      });\n    }\n\n    return null;\n  }();\n  /**\r\n   * Contains the interval handler if Interval is present.\r\n   *\r\n   * @type {Interval|null}\r\n   *\r\n   * @private\r\n   *\r\n   * @see {@link https://github.com/dencreativityspace/interval|interval}\r\n   */\n\n\n  var interval = function () {\n    if (duration > 0 && Interval) {\n      new Interval();\n    }\n\n    return null;\n  }(); // Private methods\n\n  /**\r\n   * Lets the user navigate through the slideshow.\r\n   *\r\n   * @param {number} [dir=1] Number of elements next or before the current.\r\n   * @param {boolean} [cycleState=cycle] Determines if the counter must cycle.\r\n   *\r\n   * @see setCurrentSlide\r\n   * @see getSlideIndex\r\n   * @see KeepInBound\r\n   *\r\n   * @private\r\n   */\n\n\n  function navigateSlide() {\n    var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var cycleState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cycle;\n    setCurrentSlide(slides[keepInBound(getSlideIndex(current) + dir, cycleState)]);\n  }\n  /**\r\n   * Keeps slides index in bound.\r\n   *\r\n   * @param {number} index Index to check if in bound.\r\n   * @param {boolean} [cycleState=cycle] Determines if function have to keep\r\n   * in bound considering the possibility to cycle through the elements.\r\n   *\r\n   * @return {number}\r\n   * @private\r\n   */\n\n\n  function keepInBound(index) {\n    var cycleState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cycle;\n    return (cycleState && index < 0 ? slides.length + index + slides.length : index) % slides.length;\n  }\n  /**\r\n   * Gets the index of the given slide.\r\n   *\r\n   * @param {HTMLElement} slide\r\n   *\r\n   * @return {number}\r\n   *\r\n   * @private\r\n   */\n\n\n  function getSlideIndex(slide) {\n    return Array.prototype.indexOf.call(slides, slide);\n  }\n  /**\r\n   * Sets the given slide as current.\r\n   *\r\n   * @param {HTMLElement|Node} slide\r\n   *\r\n   * @private\r\n   */\n\n\n  function setCurrentSlide(slide) {\n    if (current != null) {\n      current.classList.remove(currentClass);\n    }\n\n    slide.classList.add(currentClass);\n    current = slide;\n  } // Public methods:\n\n  /**\r\n   * Shows the previous `<figure>`. If the ovelay is closed, opens it.\r\n   *\r\n   * @param   {boolean}   [cycleState]   Determines if the counter must cycle.\r\n   *\r\n   * @emits FigureGallery#fig-gallery:prev\r\n   *\r\n   * @return  {this}\r\n   */\n\n\n  this.prev = function () {\n    var cycleState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : cycle;\n    var oldCurrent = current;\n    navigateSlide(-1, cycleState);\n    var prevEvent = null;\n\n    if (typeof window.CustomEvent !== 'function') {\n      prevEvent = document.createEvent('slideshow:prev');\n      prevEvent.initCustomEvent('slideshow:prev', false, false, {\n        current: current,\n        next: oldCurrent,\n        active: that.getCurrentSlide()\n      });\n    } else {\n      prevEvent = new CustomEvent('slideshow:prev', {\n        detail: {\n          current: current,\n          next: oldCurrent,\n          active: that.getCurrentSlide()\n        }\n      });\n    }\n    /**\r\n     * Event triggered when the gallery gets navigated to the previous element.\r\n     *\r\n     * @event FigureGallery#fig-gallery:prev\r\n     * @type {object}\r\n     * @property {HTMLElement} current - Current active <figure> element in container.\r\n     * @property {HTMLElement} next - Old active <figure> element in container which succeeds the current.\r\n     * @property {HTMLElement} active - Active <figure> element in overlay.\r\n     */\n\n\n    container.dispatchEvent(prevEvent);\n    return _this;\n  };\n  /**\r\n   * Shows the next `<figure>`. If the ovelay is closed, opens it.\r\n   *\r\n   * @param   {boolean}   [cycleState]   Determines if the counter must cycle.\r\n   *\r\n   * @emits FigureGallery#fig-gallery:next\r\n   *\r\n   * @return  {this}\r\n   */\n\n\n  this.next = function () {\n    var cycleState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : cycle;\n    var oldCurrent = current;\n    navigateSlide(1, cycleState);\n    var nextEvent = null;\n\n    if (typeof window.CustomEvent !== 'function') {\n      nextEvent = document.createEvent('slideshow:next');\n      nextEvent.initCustomEvent('slideshow:next', false, false, {\n        current: current,\n        prev: oldCurrent,\n        active: that.getCurrentSlide()\n      });\n    } else {\n      nextEvent = new CustomEvent('slideshow:next', {\n        detail: {\n          current: current,\n          prev: oldCurrent,\n          active: that.getCurrentSlide()\n        }\n      });\n    }\n    /**\r\n     * Event triggered when the gallery gets navigated to the next element.\r\n     *\r\n     * @event FigureGallery#fig-gallery:next\r\n     * @type {object}\r\n     * @property {HTMLElement} current - Current active <figure> element in container.\r\n     * @property {HTMLElement} prev - Old active <figure> element in container which precedes the current.\r\n     * @property {HTMLElement} active - Active <figure> element in overlay.\r\n     */\n\n\n    container.dispatchEvent(nextEvent);\n    return _this;\n  };\n  /**\r\n   * Sets the current `<slide>`.\r\n   *\r\n   * @param   {number|HTMLElement|Node}   slide   Index of the element or the\r\n   *                                          element itself to bet setted as\r\n   *                                          current.\r\n   *\r\n   * @emits FigureGallery#fig-gallery:setted\r\n   *\r\n   * @return  {this}\r\n   *\r\n   * @throws Will throw an error if the argument is null.\r\n   * @throws Will throw an error if the argument isn't a child of the container.\r\n   * @throws Will throw an error if `throwsSlideIndexError` is set to true and if the user tries to go beyond the end-points.\r\n   * @throws Will throw an error if the argument isn't a valid element.\r\n   */\n\n\n  this.set = function (slide) {\n    if (slide == null) {\n      throw new Error('The given element is not a valid value. Please, insert an integer or a DOM element.');\n    }\n\n    if (typeof slide === 'number') {\n      if (throwsSlideIndexError) {\n        if (slide > slides.length - 1 || Math.abs(slide) > slides.length - 1) {\n          throw new Error(\"The element #\".concat(slide, \" cannot be found.\"));\n        }\n      } else {\n        slide = keepInBound(slide);\n      }\n\n      slide = slides[slide];\n    } else if (slide instanceof HTMLElement) {\n      if (getSlideIndex(slide) < 0) {\n        throw new Error('The given element is not in this slideshow.');\n      }\n    } else {\n      throw new Error('The given element is not a valid value. Please, insert an integer or a DOM element.');\n    }\n\n    var oldCurrent = current;\n    setCurrentSlide(slide);\n    var settedEvent = null;\n\n    if (typeof window.CustomEvent !== 'function') {\n      settedEvent = document.createEvent('slideshow:setted');\n      settedEvent.initCustomEvent('slideshow:setted', false, false, {\n        current: current,\n        old: oldCurrent,\n        active: that.getCurrentSlide()\n      });\n    } else {\n      settedEvent = new CustomEvent('slideshow:setted', {\n        detail: {\n          current: current,\n          old: oldCurrent,\n          active: that.getCurrentSlide()\n        }\n      });\n    }\n    /**\r\n     * Event triggered when the gallery gets setted on a specific element.\r\n     *\r\n     * @event FigureGallery#fig-gallery:setted\r\n     * @type {object}\r\n     * @property {HTMLElement} current - Current active <slide> element in container.\r\n     * @property {HTMLElement} old - Old active <slide> element in container.\r\n     * @property {HTMLElement} active - Active <slide> element in overlay.\r\n     */\n\n\n    container.dispatchEvent(settedEvent);\n    return _this;\n  };\n  /**\r\n   * Forces the update of the child list.\r\n   * Useful when browser doesn't support MutationObserver.\r\n   *\r\n   * @return  {this}\r\n   */\n\n\n  this.updateSlides = function () {\n    slides = container.querySelectorAll(slideSelector);\n\n    if (!(current in slides)) {\n      current = slides[0] || null;\n    }\n\n    return _this;\n  };\n  /**\r\n   * Returns the container element.\r\n   *\r\n   * @return  {HTMLElement}\r\n   */\n\n\n  this.getContainer = function () {\n    return container;\n  };\n  /**\r\n   * Returns the current figure element.\r\n   *\r\n   * @return  {HTMLElement|null}\r\n   */\n\n\n  this.getCurrentSlide = function () {\n    return current;\n  };\n  /**\r\n   * Returns the swipe handler instance, if exists.\r\n   *\r\n   * @return  {SwipeEvent|null}\r\n   */\n\n\n  this.getSwipeHandler = function () {\n    return swipeHandler;\n  };\n}"]}
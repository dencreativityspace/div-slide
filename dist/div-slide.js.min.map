{"version":3,"sources":["div-slide/src/div-slide.js"],"names":["Slideshow","_ref","_this","this","_ref$container","container","_ref$slideshowSelecto","slideshowSelector","_ref$slideSelector","slideSelector","_ref$currentSelector","currentSelector","_ref$cycle","duration","cycle","_ref$swipe","swipe","_ref$throwsOpenIndexE","throwsOpenIndexError","throwsSlideIndexError","document","querySelector","HTMLElement","Error","that","slideshowClass","substr","currentClass","classList","contains","add","slides","querySelectorAll","current","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","slide","value","err","return","swipeHandler","SwipeEvent","element","itemSelector","activeSelector","eventCallbacks","keyboardNavigation","e","isOpen","key","which","keyCode","prev","set","swipeNavigation","direction","detail","navigateSlide","dir","arguments","length","cycleState","setCurrentSlide","keepInBound","getSlideIndex","index","Array","prototype","indexOf","call","remove","setListenersFn","addEventListener","attach","window","m","MutationObserver","mutations","forEach","mut","type","removedNodes","values","observe","childList","oldCurrent","prevEvent","CustomEvent","createEvent","initCustomEvent","active","getCurrentSlide","dispatchEvent","nextEvent","Math","abs","concat","settedEvent","old","updateSlides","getContainer","getSwipeHandler"],"mappings":"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","file":"div-slide.js","sourcesContent":["\"use strict\";\n\n/**\r\n * Gallery that permits to see images or videos at the maximum of their sizes\r\n * or, at least the maximum that fits in the window respecting ratio.\r\n * Removes the controls and caches the overlay.\r\n *\r\n * @constructor\r\n *\r\n * @param {object} param\r\n * @param {string|HTMLElement} [param.container='#slideshow'] Container of the gallery.\r\n * @param {string} [param.slideshowSelector='.slideshow'] Gallery selector.\r\n * @param {string} [param.currentSelector='.current'] Selector of the current element.\r\n * @param {number} [param.duration=0]\r\n * @param {boolean} [param.cycle=true] Determines if the gallery can cycle when reaches the end-points.\r\n * @param {boolean} [param.swipe=false] Determines if the gallery can be navigated with swipes.\r\n * @param {boolean} [param.throwsOpenIndexError=false] Determines if the gallery can be navigated with swipes.\r\n *\r\n * @throws Will throw an error if the container argument isn't an HTMLElement.\r\n *\r\n * @version 1.0.0\r\n *\r\n * @author Gennaro Landolfi <gennarolandolfi@codedwork.it>\r\n */\nfunction Slideshow(_ref) {\n  var _this = this;\n\n  var _ref$container = _ref.container,\n      container = _ref$container === void 0 ? '#slideshow' : _ref$container,\n      _ref$slideshowSelecto = _ref.slideshowSelector,\n      slideshowSelector = _ref$slideshowSelecto === void 0 ? '.slideshow' : _ref$slideshowSelecto,\n      _ref$slideSelector = _ref.slideSelector,\n      slideSelector = _ref$slideSelector === void 0 ? '.slide' : _ref$slideSelector,\n      _ref$currentSelector = _ref.currentSelector,\n      currentSelector = _ref$currentSelector === void 0 ? '.current' : _ref$currentSelector,\n      _ref$duration = _ref.duration,\n      duration = _ref$duration === void 0 ? 0 : _ref$duration,\n      _ref$cycle = _ref.cycle,\n      cycle = _ref$cycle === void 0 ? true : _ref$cycle,\n      _ref$swipe = _ref.swipe,\n      swipe = _ref$swipe === void 0 ? false : _ref$swipe,\n      _ref$throwsOpenIndexE = _ref.throwsOpenIndexError,\n      throwsSlideIndexError = _ref$throwsOpenIndexE === void 0 ? false : _ref$throwsOpenIndexE;\n\n  // Type-checks\n  if (typeof container === 'string') {\n    container = document.querySelector(container);\n  }\n\n  if (!(container instanceof HTMLElement)) {\n    throw new Error('The slideshow container must be a valid DOM element.');\n  } // Shorthand to easily reach `this`.\n\n\n  var that = this; // Class mapping:\n\n  /**\r\n   * CSS class of the slideshow. Applies to container.\r\n   *\r\n   * @constant\r\n   * @type {string}\r\n   *\r\n   * @private\r\n   */\n\n  var slideshowClass = slideshowSelector.substr(1);\n  /**\r\n   * CSS class of the slide. Applies to container.\r\n   *\r\n   * @constant\r\n   * @type {string}\r\n   *\r\n   * @private\r\n   */\n\n  var slideClass = slideSelector.substr(1);\n  /**\r\n   * CSS class for the current slide. Applies to the original selected <div>\r\n   * and the chosen one. Can be applied only to one element at the time.\r\n   *\r\n   * @constant\r\n   * @type {string}\r\n   *\r\n   * @private\r\n   */\n\n  var currentClass = currentSelector.substr(1); // Sets the slideshow class.\n\n  if (!container.classList.contains(slideshowClass)) {\n    container.classList.add(slideshowClass);\n  }\n  /**\r\n   * Gets all the slides.\r\n   *\r\n   * @type {NodeList}\r\n   *\r\n   * @private\r\n   */\n\n\n  var slides = container.querySelectorAll(slideSelector);\n  /**\r\n  * Represents the current element in container.\r\n  *\r\n  * @type {HTMLElement}\r\n  *\r\n  * @private\r\n  */\n\n  var current = function () {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = slides[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var slide = _step.value;\n\n        if (slide.classList.contains(currentClass)) {\n          return slide;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return slides[0] || null;\n  }();\n  /**\r\n  * Contains the swipe handler if SwipeEvent is present.\r\n  *\r\n  * @type {SwipeEvent|null}\r\n  *\r\n  * @private\r\n  *\r\n  * @see {@link https://github.com/dencreativityspace/swipe-event|swipe-event}\r\n  */\n\n\n  var swipeHandler = function () {\n    if (swipe && typeof SwipeEvent === 'function') {\n      return new SwipeEvent({\n        element: container,\n        itemSelector: slideSelector,\n        activeSelector: currentSelector\n      });\n    }\n\n    return null;\n  }();\n  /**\r\n  * Stores the callbacks for the events.\r\n  *\r\n  * @type {object}\r\n  *\r\n  * @private\r\n  */\n\n\n  var eventCallbacks = {\n    keyboardNavigation: function keyboardNavigation(e) {\n      if (that.isOpen()) {\n        var key = e.key || e.which || e.keyCode || 0;\n\n        switch (key) {\n          case 37:\n            // Left arrow\n            that.prev();\n            break;\n\n          case 39:\n            // Right arrow\n            that.next();\n            break;\n\n          case 36:\n            // Home\n            that.set(0);\n            break;\n\n          case 35:\n            // End\n            that.set(-1);\n            break;\n        }\n      }\n    },\n    swipeNavigation: function swipeNavigation(e) {\n      var direction = e.detail.direction || e.direction || null;\n\n      if (direction === 'left') {\n        that.prev();\n      } else if (direction === 'right') {\n        that.next();\n      }\n    },\n    buttons: createButtonsCallbacks()\n  }; // Private methods\n\n  /**\r\n   * Lets the user navigate through the slideshow.\r\n   *\r\n   * @param {number} [dir=1] Number of elements next or before the current.\r\n   * @param {boolean} [cycleState=cycle] Determines if the counter must cycle.\r\n   *\r\n   * @see setCurrentSlide\r\n   * @see getSlideIndex\r\n   * @see KeepInBound\r\n   *\r\n   * @private\r\n   */\n\n  function navigateSlide() {\n    var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var cycleState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cycle;\n    setCurrentSlide(slides[keepInBound(getSlideIndex(current) + dir, cycleState)]);\n  }\n  /**\r\n   * Keeps slides index in bound.\r\n   *\r\n   * @param {number} index Index to check if in bound.\r\n   * @param {boolean} [cycleState=cycle] Determines if function have to keep\r\n   * in bound considering the possibility to cycle through the elements.\r\n   *\r\n   * @return {number}\r\n   * @private\r\n   */\n\n\n  function keepInBound(index) {\n    var cycleState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cycle;\n    return (cycleState && index < 0 ? slides.length + index + slides.length : index) % slides.length;\n  }\n  /**\r\n   * Gets the index of the given slide.\r\n   *\r\n   * @param {HTMLElement} slide\r\n   *\r\n   * @return {number}\r\n   *\r\n   * @private\r\n   */\n\n\n  function getSlideIndex(slide) {\n    return Array.prototype.indexOf.call(slides, slide);\n  }\n  /**\r\n   * Sets the given slide as current.\r\n   *\r\n   * @param {HTMLElement|Node} slide\r\n   *\r\n   * @private\r\n   */\n\n\n  function setCurrentSlide(slide) {\n    if (current != null) {\n      current.classList.remove(currentClass);\n    }\n\n    slide.classList.add(currentClass);\n    current = slide;\n  }\n  /**\r\n   * Creates the object that will containt the button callbacks.\r\n   * Returns `null` if `overlay` doesn't exists.\r\n   * Useful for caching.\r\n   *\r\n   * @return {object|null}\r\n   *\r\n   * @see overlay\r\n   *\r\n   * @private\r\n   */\n\n\n  function createButtonsCallbacks() {\n    /*if (overlay) {\r\n        let callbacks = {};\r\n          for (const type of Object.keys(overlay.buttons)) {\r\n            callbacks[type] = (e) => {\r\n                e.stopImmediatePropagation();\r\n                  that[type]();\r\n            };\r\n        }\r\n          return callbacks;\r\n    }*/\n    return null;\n  } // Event Listeners\n\n  /**\r\n   * Adds or removes all the event listeners to container.\r\n   * Uses `createButtonsCallbacks()` to create the button callbacks and\r\n   * appends them to `eventCallbacks`.\r\n   *\r\n   * @function\r\n   *\r\n   * @param {boolean} [forceFigures=false] Determines if the update must be forced.\r\n   * Useful when MutationObserver isn't supported.\r\n   *\r\n   * @see createButtonsCallbacks\r\n   * @see eventCallbacks\r\n   *\r\n   * @private\r\n   */\n\n\n  var setListeners = function setListenersFn() {\n    var forceFigures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    // Keyboard navigation\n    container.addEventListener('keydown', eventCallbacks.keyboardNavigation); // Swipe navigation - since 1.1.0\n\n    if (swipeHandler) {\n      swipeHandler.attach();\n      /**\r\n       * @listens SwipeEvent#swipe\r\n       * @see {@link https://github.com/dencreativityspace/swipe-event|SwipeEvent}\r\n       */\n\n      container.addEventListener('swipe', eventCallbacks.swipeNavigation);\n    }\n\n    return setListenersFn;\n  }(true);\n  /**\r\n   * Will contain MutationObserver instance if supported.\r\n   *\r\n   * @constant\r\n   * @type {MutationObserver|null}\r\n   *\r\n   * @private\r\n   */\n\n\n  var mutation = function () {\n    if ('MutationObserver' in window) {\n      var m = new MutationObserver(function (mutations) {\n        mutations.forEach(function (mut) {\n          if (mut.type === 'childList') {\n            slides = container.querySelectorAll(slideSelector);\n\n            if (mut.removedNodes && current in mut.removedNodes.values()) {\n              current = slides[0] || null;\n            }\n          }\n        });\n      });\n      m.observe(container, {\n        childList: true\n      });\n      return m;\n    }\n\n    return null;\n  }(); // Public methods\n\n  /**\r\n   * Shows the previous `<figure>`. If the ovelay is closed, opens it.\r\n   *\r\n   * @param   {boolean}   [cycleState]   Determines if the counter must cycle.\r\n   *\r\n   * @emits FigureGallery#fig-gallery:prev\r\n   *\r\n   * @return  {this}\r\n  */\n\n\n  this.prev = function () {\n    var cycleState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : cycle;\n    var oldCurrent = current;\n    navigateSlide(-1, cycleState);\n    var prevEvent = null;\n\n    if (typeof window.CustomEvent !== 'function') {\n      prevEvent = document.createEvent('slideshow:prev');\n      prevEvent.initCustomEvent('slideshow:prev', false, false, {\n        current: current,\n        next: oldCurrent,\n        active: that.getCurrentSlide()\n      });\n    } else {\n      prevEvent = new CustomEvent('slideshow:prev', {\n        detail: {\n          current: current,\n          next: oldCurrent,\n          active: that.getCurrentSlide()\n        }\n      });\n    }\n    /**\r\n     * Event triggered when the gallery gets navigated to the previous element.\r\n     *\r\n     * @event FigureGallery#fig-gallery:prev\r\n     * @type {object}\r\n     * @property {HTMLElement} current - Current active <figure> element in container.\r\n     * @property {HTMLElement} next - Old active <figure> element in container which succeeds the current.\r\n     * @property {HTMLElement} active - Active <figure> element in overlay.\r\n     */\n\n\n    container.dispatchEvent(prevEvent);\n    return _this;\n  };\n  /**\r\n   * Shows the next `<figure>`. If the ovelay is closed, opens it.\r\n   *\r\n   * @param   {boolean}   [cycleState]   Determines if the counter must cycle.\r\n   *\r\n   * @emits FigureGallery#fig-gallery:next\r\n   *\r\n   * @return  {this}\r\n  */\n\n\n  this.next = function () {\n    var cycleState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : cycle;\n    var oldCurrent = current;\n    navigateSlide(1, cycleState);\n    var nextEvent = null;\n\n    if (typeof window.CustomEvent !== 'function') {\n      nextEvent = document.createEvent('slideshow:next');\n      nextEvent.initCustomEvent('slideshow:next', false, false, {\n        current: current,\n        prev: oldCurrent,\n        active: that.getCurrentSlide()\n      });\n    } else {\n      nextEvent = new CustomEvent('slideshow:next', {\n        detail: {\n          current: current,\n          prev: oldCurrent,\n          active: that.getCurrentSlide()\n        }\n      });\n    }\n    /**\r\n     * Event triggered when the gallery gets navigated to the next element.\r\n     *\r\n     * @event FigureGallery#fig-gallery:next\r\n     * @type {object}\r\n     * @property {HTMLElement} current - Current active <figure> element in container.\r\n     * @property {HTMLElement} prev - Old active <figure> element in container which precedes the current.\r\n     * @property {HTMLElement} active - Active <figure> element in overlay.\r\n     */\n\n\n    container.dispatchEvent(nextEvent);\n    return _this;\n  };\n  /**\r\n   * Sets the current `<slide>`.\r\n   *\r\n   * @param   {number|HTMLElement|Node}   slide   Index of the element or the\r\n   *                                          element itself to bet setted as\r\n   *                                          current.\r\n   *\r\n   * @emits FigureGallery#fig-gallery:setted\r\n   *\r\n   * @return  {this}\r\n   *\r\n   * @throws Will throw an error if the argument is null.\r\n   * @throws Will throw an error if the argument isn't a child of the container.\r\n   * @throws Will throw an error if `throwsSlideIndexError` is set to true and if the user tries to go beyond the end-points.\r\n   * @throws Will throw an error if the argument isn't a valid element.\r\n  */\n\n\n  this.set = function (slide) {\n    if (!slide) {\n      throw new Error('The given element is not a valid value. Please, insert an integer or a DOM element.');\n    }\n\n    if (typeof slide === 'number') {\n      if (throwsSlideIndexError) {\n        if (slide > slides.length - 1 || Math.abs(slide) > slides.length - 1) {\n          throw new Error(\"The element #\".concat(slide, \" cannot be found.\"));\n        }\n      } else {\n        slide = keepInBound(slide);\n      }\n\n      slide = slides[slide];\n    } else if (slide instanceof HTMLElement) {\n      if (getSlideIndex(slide) < 0) {\n        throw new Error('The given element is not in this gallery.');\n      }\n    } else {\n      throw new Error('The given element is not a valid value. Please, insert an integer or a DOM element.');\n    }\n\n    var oldCurrent = current;\n    setCurrentSlide(slide);\n    var settedEvent = null;\n\n    if (typeof window.CustomEvent !== 'function') {\n      settedEvent = document.createEvent('slideshow:setted');\n      settedEvent.initCustomEvent('slideshow:setted', false, false, {\n        current: current,\n        old: oldCurrent,\n        active: that.getCurrentSlide()\n      });\n    } else {\n      settedEvent = new CustomEvent('slideshow:setted', {\n        detail: {\n          current: current,\n          old: oldCurrent,\n          active: that.getCurrentSlide()\n        }\n      });\n    }\n    /**\r\n     * Event triggered when the gallery gets setted on a specific element.\r\n     *\r\n     * @event FigureGallery#fig-gallery:setted\r\n     * @type {object}\r\n     * @property {HTMLElement} current - Current active <slide> element in container.\r\n     * @property {HTMLElement} old - Old active <slide> element in container.\r\n     * @property {HTMLElement} active - Active <slide> element in overlay.\r\n     */\n\n\n    container.dispatchEvent(settedEvent);\n    return _this;\n  };\n  /**\r\n   * Forces the update of the child list.\r\n   * Useful when browser doesn't support MutationObserver.\r\n   *\r\n   * @return  {this}\r\n  */\n\n\n  this.updateSlides = function () {\n    slides = container.querySelectorAll(slideSelector);\n\n    if (!(current in slides)) {\n      current = slides[0] || null;\n    }\n\n    return _this;\n  };\n  /**\r\n   * Returns the container element.\r\n   *\r\n   * @return  {HTMLElement}\r\n  */\n\n\n  this.getContainer = function () {\n    return container;\n  };\n  /**\r\n   * Returns the current figure element.\r\n   *\r\n   * @return  {HTMLElement|null}\r\n  */\n\n\n  this.getCurrentSlide = function () {\n    return current;\n  };\n  /**\r\n   * Returns the swipe handler instance, if exists.\r\n   *\r\n   * @return  {SwipeEvent|null}\r\n   */\n\n\n  this.getSwipeHandler = function () {\n    return swipeHandler;\n  };\n}"]}